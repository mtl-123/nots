const e=JSON.parse('{"key":"v-78e9b099","path":"/codenotes/algdata/lbld/%E7%AE%97%E6%B3%95%E5%B0%8F%E6%8A%84%E6%A0%B8%E5%BF%83%E5%A5%97%E8%B7%AF.html","title":"核心套路","lang":"zh-CN","frontmatter":{"title":"核心套路","icon":"write","category":["算法","数据结构"],"tag":["算法","数据结构"],"sticky":false,"star":false,"article":true,"timeline":true,"description":"学习算法和刷题的框架思维 学习解决问题的思路、套路、框架，养成“框架思维”，不应该纠结于问题的细节，把握问题的共性和本质，做到举一反三。 数据结构的存储方式 数据结构的底层存储方式只有两种：数组（顺序存储）和链表（链式存储）。 其他的数据结构，比如哈希表、栈、队列、堆、树、图等都是属于具体的上层建筑，都是在数组或者链表上的特殊操作，只是API特性不同而已。 数组 数组由于是紧凑连续存储，因此可以随机访问，通过索引快速找到对应的元素，而且相对节约存储空间。但正因为连续存储，内存空间必须一次性分配足，所以数组如果要扩容，需要先重新分配一块更大的空间，再把数据全部复制进去，时间复杂度为O(N)；而且如果想在数组中间和开始位置进行插入和删除操作，每次必须移动后面的所有数据以保持连续，时间复杂度为O(N)。 数组在开始、中间、最后位置的增删改查分析如下： 开始位置：增加和删除都需要挪动元素，所以效率不高，但是查询和修改就比较高效。 中间位置：增加和删除都需要挪动元素，所以效率不高，但是查询和修改就比较高效。 最后位置：增加和删除位置不需要挪动元素，效率比较高，同时查询和修改效率也比较高。","head":[["meta",{"property":"og:url","content":"https://gitee.com/oucystong/nots/codenotes/algdata/lbld/%E7%AE%97%E6%B3%95%E5%B0%8F%E6%8A%84%E6%A0%B8%E5%BF%83%E5%A5%97%E8%B7%AF.html"}],["meta",{"property":"og:site_name","content":"小佟の学习笔记"}],["meta",{"property":"og:title","content":"核心套路"}],["meta",{"property":"og:description","content":"学习算法和刷题的框架思维 学习解决问题的思路、套路、框架，养成“框架思维”，不应该纠结于问题的细节，把握问题的共性和本质，做到举一反三。 数据结构的存储方式 数据结构的底层存储方式只有两种：数组（顺序存储）和链表（链式存储）。 其他的数据结构，比如哈希表、栈、队列、堆、树、图等都是属于具体的上层建筑，都是在数组或者链表上的特殊操作，只是API特性不同而已。 数组 数组由于是紧凑连续存储，因此可以随机访问，通过索引快速找到对应的元素，而且相对节约存储空间。但正因为连续存储，内存空间必须一次性分配足，所以数组如果要扩容，需要先重新分配一块更大的空间，再把数据全部复制进去，时间复杂度为O(N)；而且如果想在数组中间和开始位置进行插入和删除操作，每次必须移动后面的所有数据以保持连续，时间复杂度为O(N)。 数组在开始、中间、最后位置的增删改查分析如下： 开始位置：增加和删除都需要挪动元素，所以效率不高，但是查询和修改就比较高效。 中间位置：增加和删除都需要挪动元素，所以效率不高，但是查询和修改就比较高效。 最后位置：增加和删除位置不需要挪动元素，效率比较高，同时查询和修改效率也比较高。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:updated_time","content":"2022-12-17T16:28:51.000Z"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:tag","content":"算法"}],["meta",{"property":"article:tag","content":"数据结构"}],["meta",{"property":"article:modified_time","content":"2022-12-17T16:28:51.000Z"}]]},"headers":[{"level":2,"title":"学习算法和刷题的框架思维","slug":"学习算法和刷题的框架思维","link":"#学习算法和刷题的框架思维","children":[{"level":3,"title":"数据结构的存储方式","slug":"数据结构的存储方式","link":"#数据结构的存储方式","children":[]},{"level":3,"title":"数据结构的基本操作","slug":"数据结构的基本操作","link":"#数据结构的基本操作","children":[]},{"level":3,"title":"算法刷题指南","slug":"算法刷题指南","link":"#算法刷题指南","children":[]}]},{"level":2,"title":"动态规划解题套路框架","slug":"动态规划解题套路框架","link":"#动态规划解题套路框架","children":[]},{"level":2,"title":"回溯算法解题套路框架","slug":"回溯算法解题套路框架","link":"#回溯算法解题套路框架","children":[{"level":3,"title":"全排列问题","slug":"全排列问题","link":"#全排列问题","children":[]},{"level":3,"title":"N皇后问题","slug":"n皇后问题","link":"#n皇后问题","children":[]},{"level":3,"title":"最后总结","slug":"最后总结","link":"#最后总结","children":[]}]},{"level":2,"title":"BFS算法套路框架","slug":"bfs算法套路框架","link":"#bfs算法套路框架","children":[{"level":3,"title":"算法框架","slug":"算法框架","link":"#算法框架","children":[]},{"level":3,"title":"二叉树的最小高度","slug":"二叉树的最小高度","link":"#二叉树的最小高度","children":[]},{"level":3,"title":"解开密码锁的最少次数","slug":"解开密码锁的最少次数","link":"#解开密码锁的最少次数","children":[]}]},{"level":2,"title":"双指针技巧套路框架","slug":"双指针技巧套路框架","link":"#双指针技巧套路框架","children":[{"level":3,"title":"快慢指针的常用算法","slug":"快慢指针的常用算法","link":"#快慢指针的常用算法","children":[]},{"level":3,"title":"左右指针的常用算法","slug":"左右指针的常用算法","link":"#左右指针的常用算法","children":[]}]},{"level":2,"title":"二分搜索算法","slug":"二分搜索算法","link":"#二分搜索算法","children":[{"level":3,"title":"二分搜索框架","slug":"二分搜索框架","link":"#二分搜索框架","children":[]},{"level":3,"title":"寻找一个数（基本的二分搜索）","slug":"寻找一个数-基本的二分搜索","link":"#寻找一个数-基本的二分搜索","children":[]},{"level":3,"title":"寻找左侧边界的二分搜索","slug":"寻找左侧边界的二分搜索","link":"#寻找左侧边界的二分搜索","children":[]},{"level":3,"title":"寻找右侧边界的二分搜索","slug":"寻找右侧边界的二分搜索","link":"#寻找右侧边界的二分搜索","children":[]},{"level":3,"title":"逻辑统一","slug":"逻辑统一","link":"#逻辑统一","children":[]}]},{"level":2,"title":"滑动窗口算法变成默写题","slug":"滑动窗口算法变成默写题","link":"#滑动窗口算法变成默写题","children":[{"level":3,"title":"最小覆盖子串","slug":"最小覆盖子串","link":"#最小覆盖子串","children":[]},{"level":3,"title":"字符串排列","slug":"字符串排列","link":"#字符串排列","children":[]},{"level":3,"title":"找所有字母异位词","slug":"找所有字母异位词","link":"#找所有字母异位词","children":[]},{"level":3,"title":"最长无重复子串","slug":"最长无重复子串","link":"#最长无重复子串","children":[]}]}],"git":{"createdTime":1671294531000,"updatedTime":1671294531000,"contributors":[{"name":"MeiChen","email":"13316899740@163.com","commits":1}]},"readingTime":{"minutes":24.8,"words":7441},"filePathRelative":"codenotes/algdata/lbld/算法小抄核心套路.md","localizedDate":"2022年12月18日","excerpt":"<h2> 学习算法和刷题的框架思维</h2>\\n<p>学习解决问题的<strong>思路、套路、框架</strong>，养成“框架思维”，<strong>不应该纠结于问题的细节</strong>，把握问题的共性和本质，做到举一反三。</p>\\n<h3> 数据结构的存储方式</h3>\\n<p>数据结构的底层存储方式只有两种：<code>数组（顺序存储）和链表（链式存储）</code>。</p>\\n<p>其他的数据结构，比如哈希表、栈、队列、堆、树、图等都是属于具体的上层建筑，都是在数组或者链表上的特殊操作，只是<code>API</code>特性不同而已。</p>\\n<div class=\\"custom-container tip\\">\\n<p class=\\"custom-container-title\\">数组</p>\\n<p>数组由于是紧凑连续存储，因此可以随机访问，通过索引快速找到对应的元素，而且相对节约存储空间。但正因为连续存储，内存空间必须一次性分配足，所以数组如果要扩容，需要先重新分配一块更大的空间，再把数据全部复制进去，时间复杂度为<code>O(N)</code>；而且如果想在数组中间和开始位置进行插入和删除操作，每次必须移动后面的所有数据以保持连续，时间复杂度为<code>O(N)</code>。</p>\\n<p><strong>数组在开始、中间、最后位置的增删改查分析如下：</strong></p>\\n<ul>\\n<li>开始位置：增加和删除都需要挪动元素，所以效率不高，但是查询和修改就比较高效。</li>\\n<li>中间位置：增加和删除都需要挪动元素，所以效率不高，但是查询和修改就比较高效。</li>\\n<li>最后位置：增加和删除位置不需要挪动元素，效率比较高，同时查询和修改效率也比较高。</li>\\n</ul>\\n</div>","autoDesc":true}');export{e as data};
